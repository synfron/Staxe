using Synfron.Staxe.Matcher.Input.Patterns;
using System.Collections.Generic;
using System.Linq;
using System.Reflection;
using System.Text.RegularExpressions;
using System.Web;

namespace Synfron.Staxe.Matcher.Input
{
	public class LanguageMatcher
	{
		public string Name { get; set; }

		public List<PatternMatcher> Patterns { get; set; }

		public FragmentMatcher StartingFragment { get; set; }

		public List<FragmentMatcher> Fragments { get; set; }

		public bool LogMatches { get; set; }

		public IndexingMode IndexingMode { get; set; } = IndexingMode.Lazy;


		public string Generate(MatcherEngineGenerator generator)
		{
			string version = AssemblyName.GetAssemblyName(GetType().Assembly.Location).Version.ToString();
			return $@"
/* Generated by Synfron.Staxe.Matcher v{version}*/

using Synfron.Staxe.Matcher.Data;
using System.Collections.Generic;
using System;
using System.Linq;
using Synfron.Staxe.Matcher.Input;
{(generator.LanguageMatcher.LogMatches ? "using System.Text;" : null)}

namespace Synfron.Staxe.Matcher
{{
    public class {GetSafeMethodName(Name)}MatchEngine : AbstractLanguageMatchEngine
    {{

        {GenerateMatch(generator)}

        <<Generated Methods>>
    }}
}}";
		}

		private string GenerateMatch(MatcherEngineGenerator generator)
		{
			return $@"
        public override MatcherResult Match(string code, string fragmentMatcher, bool matchFullText = true)
        {{
            FragmentMatchData matchData = new FragmentMatchData
            {{
                StartIndex = 0
            }};
            
			{(IndexingMode == IndexingMode.Lazy ? $"Span<int> checkFlags = stackalloc int[{Patterns.Count + 1}];" : null)}

            State state = new State()
            {{
                Code = code{(IndexingMode != IndexingMode.None ? @",
				DistinctStringMatches = new List<StringMatchData>(2000)" : null)}{(IndexingMode == IndexingMode.Lazy ? @",
				CheckFlags = checkFlags" : null)}{(Fragments.Any(fragment => fragment.Cacheable) ? @",
				MatchCache = new Dictionary<ValueTuple<string, int>, FragmentMatchData>()" : null)}{(LogMatches ? $@",
				MatchLogBuilder = new StringBuilder()" : null)}
            }};
            
			{(IndexingMode == IndexingMode.Eager ? "PreMatchPatterns(ref state);" : null)}

			bool success = false;
            switch (fragmentMatcher) 
            {{
                {string.Join("\n", Fragments.Where(matcher => !matcher.FallThrough && !matcher.IsNoise).Select(matcher => $@"
                case ""{HttpUtility.JavaScriptStringEncode(matcher.Name)}"":
                        success = {matcher.Generate(generator)};
                    break;
                "))}
            }}

			IMatchData resultMatchData = matchData.Parts.FirstOrDefault();
			int? failureIndex = success ? null : state.FailureIndex;

			if (success && matchFullText && state.CurrentIndex != state.Code.Length)
			{{
				success = false;
				failureIndex = state.CurrentIndex;
			}}

			return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }}

        public override MatcherResult Match(string code, bool matchFullText = true)
        {{
            FragmentMatchData matchData = new FragmentMatchData
            {{
                StartIndex = 0
            }};
            
			{(IndexingMode == IndexingMode.Lazy ? $"Span<int> checkFlags = stackalloc int[{Patterns.Count + 1}];" : null)}

            State state = new State()
            {{
                Code = code{(IndexingMode != IndexingMode.None ? @",
				DistinctStringMatches = new List<StringMatchData>(2000)" : null)}{(IndexingMode == IndexingMode.Lazy ? @",
				CheckFlags = checkFlags" : null)}{(Fragments.Any(fragment => fragment.Cacheable) ? @",
				MatchCache = new Dictionary<ValueTuple<string, int>, FragmentMatchData>()" : null)}{(LogMatches ? $@",
				MatchLogBuilder = new StringBuilder()" : null)}
            }};
            
			{(IndexingMode == IndexingMode.Eager ? "PreMatchPatterns(ref state);" : null)}

            bool success = {StartingFragment.Generate(generator)};

			IMatchData resultMatchData = matchData?.Parts.FirstOrDefault();
			int? failureIndex = success ? null : state.FailureIndex;

			if (success && matchFullText && state.CurrentIndex != state.Code.Length)
			{{
				success = false;
				failureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
			}}

			return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }}

		{(IndexingMode == IndexingMode.Eager ? $@"private bool PreMatchPatterns(ref State state)
		{{
			int codeLength = state.Code.Length;
			bool success = true;
			bool previousNoise = false;
			StringMatchData matchData = null;
			int currentIndex = 0;
			while ((currentIndex = state.CurrentIndex) < codeLength)
			{{
				success = {string.Join(" ||\n", Patterns.Select(pattern => $@"{string.Format(GenerateMatchPattern(generator, pattern), "matchData", "true", "false")}"))};
				if (!success)
				{{
					break;
				}}
				else {{
					{(generator.LanguageMatcher.LogMatches ? $@"state.MatchLogBuilder.AppendLine($""{{currentIndex}}. Prematched {{matchData.Name}}: {{matchData.Text}}"");" : null)}
					if (matchData.IsNoise)
					{{
						previousNoise = true;
					}}
					else if (previousNoise)
					{{
						if (state.DistinctIndex > 1)
						{{
							StringMatchData previousMatchData = state.DistinctStringMatches[state.DistinctIndex - 2];
							if (previousMatchData.Name == matchData.Name && previousMatchData.Mergable)
							{{
								previousMatchData.Text += matchData.Text;
								previousMatchData.Length = state.CurrentIndex - previousMatchData.StartIndex;
								state.DistinctIndex--;
								state.MaxDistinctIndex--;
								state.DistinctStringMatches.RemoveAt(state.DistinctIndex);
							}}
						}}
						previousNoise = false;
					}}
				}}
			}}
			state.CurrentIndex = 0;
			{(IndexingMode != IndexingMode.None ? "state.DistinctIndex = 0;" : null)}
			return success;
		}}" : null)}";
		}


		public string GenerateMatchPattern(MatcherEngineGenerator generator, PatternMatcher pattern)
		{
			string methodName = $"MatchPattern{GetSafeMethodName(pattern.Name)}";
			string method = $"{methodName}(ref state, out {{0}}, {{1}}, {{2}})";
			if (!generator.TryGetMethod(methodName, ref method))
			{
				generator.Add(methodName, method);
				string code = $@"private bool {methodName}(ref State state, out StringMatchData matchData, bool required, bool readOnly = false)
            {{
                bool success = false;
                {(generator.IndexingMode != IndexingMode.None ? $@"int distinctIndex = state.DistinctIndex;
                if (distinctIndex >= state.MaxDistinctIndex)
                {{" : null)}
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = {GenerateRawMatchPattern(generator, pattern)};
					matchData = default;
					if (success)
					{{
						matchData = new StringMatchData
						{{
							Name = ""{HttpUtility.JavaScriptStringEncode(pattern.Name)}"",
							Text = state.Code.Substring(startOffset, length),
							StartIndex = startOffset,
							Length = length,
							IsNoise = {pattern.IsNoise.ToString().ToLower()},
							Mergable = {pattern.Mergable.ToString().ToLower()},
							Id = {pattern.Id}
						}};
						{(!pattern.IsNoise && generator.IndexingMode != IndexingMode.None ? $@"state.DistinctStringMatches.Add(matchData);" : null)}
						success = matchData != null;
						{(generator.IndexingMode == IndexingMode.Lazy ? $@"state.CheckFlags[{pattern.Id}] = distinctIndex + 1;" : null)}
						{(!pattern.IsNoise && generator.IndexingMode != IndexingMode.None ? $@"state.MaxDistinctIndex++;" : null)}
						if (!readOnly)
						{{
							{(!pattern.IsNoise && generator.IndexingMode != IndexingMode.None ? $@"state.DistinctIndex++;" : null)}
							state.CurrentIndex += matchData.Length;
						}}
					}}
					else if (!required)
					{{
						success = true;
					}}
					return success;
                {(generator.IndexingMode != IndexingMode.None ? $@"}}
                else
                {{
					matchData = state.DistinctStringMatches[distinctIndex];
                    if (matchData != null)
                    {{
						success = matchData.Id == {pattern.Id};
                    }}
                    else
                    {{
                        {(generator.IndexingMode == IndexingMode.Eager ? $@"if (state.CheckFlags[{pattern.Id}] < distinctIndex + 1)
                        {{" : null)}
                            int length;
                            int startOffset = state.CurrentIndex;
                            (success, length) = {GenerateRawMatchPattern(generator, pattern)};
                            if (success)
                            {{
								matchData = new StringMatchData
								{{
									Name = ""{GetSafeMethodName(pattern.Name)}"",
									Text = state.Code.Substring(startOffset, length),
									StartIndex = startOffset,
									Length = length,
									IsNoise = {pattern.IsNoise.ToString().ToLower()},
									Mergable = {pattern.Mergable.ToString().ToLower()},
									Id = {pattern.Id}
								}};
								{(!pattern.IsNoise ? $@"state.DistinctStringMatches[distinctIndex] = matchData;" : null)}
                            }}
                            {(generator.IndexingMode == IndexingMode.Eager ? $@"state.CheckFlags[{pattern.Id}] = distinctIndex + 1;
                        }}" : null)}
                    }}
					if (success && !readOnly)
					{{
						{(!pattern.IsNoise ? $@"state.DistinctIndex++;" : null)}
						state.CurrentIndex += matchData.Length;
					}}
					if (!required)
					{{
						success = true;
					}}
					return success;
                }}" : null)}
            }}";
				method = generator.Add(method, methodName, code);
			}
			return method;
		}

		private string GenerateRawMatchPattern(MatcherEngineGenerator generator, PatternMatcher pattern)
		{
			return string.Format(pattern.Generate(generator), "state.Code", "state.CurrentIndex");
		}

		private static string GetSafeMethodName(string name)
		{
			return Regex.Replace(name, @"\W", (match) => $"x{((int)match.Value[0]).ToString()}");
		}
	}
}
