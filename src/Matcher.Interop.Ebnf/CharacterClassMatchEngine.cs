/* Generated by Synfron.Staxe.Matcher v0.8.0.0*/
using Synfron.Staxe.Matcher.Data;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Synfron.Staxe.Matcher.Interop.Bnf
{
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0059:Unnecessary assignment of a value", Justification = "<Pending>")]
    [System.Diagnostics.CodeAnalysis.SuppressMessage("Style", "IDE0046:Convert to conditional expression", Justification = "<Pending>")]
    public class CharacterClassMatchEngine : AbstractLanguageMatchEngine
    {
        public override MatcherResult Match(string code, string fragmentMatcher, bool matchFullText = true)
        {
            FragmentMatchData matchData = new FragmentMatchData { StartIndex = 0 };
            Span<int> checkFlags = stackalloc int[7];
            State state = new State()
            { Code = code, DistinctStringMatches = new List<StringMatchData>(2000) };
            bool success = false;
            switch (fragmentMatcher)
            {
                case "NotCharacterClassBody":
                    success = MatchFragmentNotCharacterClassBody(ref state, matchData);
                    break;
                case "CharacterClassBody":
                    success = MatchFragmentCharacterClassBody(ref state, matchData);
                    break;
                case "CharacterRange":
                    success = MatchFragmentCharacterRange(ref state, matchData);
                    break;
                case "HexRange":
                    success = MatchFragmentHexRange(ref state, matchData);
                    break;
            }

            IMatchData resultMatchData = matchData.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex != state.Code.Length)
            {
                success = false;
                failureIndex = state.CurrentIndex;
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        public override MatcherResult Match(string code, bool matchFullText = true)
        {
            FragmentMatchData matchData = new FragmentMatchData { StartIndex = 0 };
            Span<int> checkFlags = stackalloc int[7];
            State state = new State()
            { Code = code, DistinctStringMatches = new List<StringMatchData>(2000) };
            bool success = MatchFragmentCharacterClass(ref state, matchData);
            IMatchData resultMatchData = matchData?.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex != state.Code.Length)
            {
                success = false;
                failureIndex = state.CurrentIndex;
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        private (bool success, int offset) MatchLiteral0(string text, int startOffset)
        {
            string literal = "^";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, StringMatchData matchData) MatchPatternCaret(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchLiteral0(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "Caret", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 3 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 3;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 3;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchLiteral0(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "Caret", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 3 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchFragmentBoundsCaret(ref State state, bool readOnly, out StringMatchData matchData)
        {
            bool success;
            (success, matchData) = MatchPatternCaret(ref state, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchInsensitiveLiteral0(string text, int startOffset)
        {
            string literal = "#x";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (char.ToLowerInvariant(text[i + startOffset]) != char.ToLowerInvariant(literal[i]))
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchCharBounds0(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (97 <= charVal && 102 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds1(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (65 <= charVal && 70 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds2(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (48 <= charVal && 57 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchOr0(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchCharBounds0(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds1(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds2(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchCountBounds0(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            int subOffset;
            int matches = 0;
            for (; matches < 4 && subSuccess; matches++)
            {
                (subSuccess, subOffset) = MatchOr0(text, offset);
                offset += subOffset;
            }

            bool success = subSuccess || matches >= 1;
            return success ? (true, offset - startOffset) : (false, 0);
        }

        private (bool success, int offset) MatchGroup0(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchInsensitiveLiteral0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchCountBounds0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, StringMatchData matchData) MatchPatternHexChar(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchGroup0(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "HexChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 4 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 4;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 4;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchGroup0(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "HexChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 4 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchPartByTextMatcherHexChar(ref State state, FragmentMatchData matchData)
        {
            (bool success, StringMatchData partMatchData) = MatchPatternHexChar(ref state, true, false);
            if (success)
            {
                matchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral1(string text, int startOffset)
        {
            string literal = "-";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, StringMatchData matchData) MatchPatternDash(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchLiteral1(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "Dash", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 5 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 5;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 5;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchLiteral1(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "Dash", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 5 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchFragmentPartsOrderedModeHexRange(ref State state, FragmentMatchData matchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherHexChar(ref state, matchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            (partSuccess, stringMatchData) = MatchPatternDash(ref state, true, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchPartByTextMatcherHexChar(ref state, matchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

        Break:
            success = success || 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentHexRange(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            FragmentMatchData partMatcherData = null;
            int startIndex = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            partMatcherData = new FragmentMatchData { Name = "HexRange", StartIndex = state.CurrentIndex };
            success = (MatchFragmentPartsOrderedModeHexRange(ref state, partMatcherData));
            if (success)
            {
                partMatcherData.Length = state.CurrentIndex - partMatcherData.StartIndex;
                partMatcherData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                matchData.Parts.Add(partMatcherData);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral2(string text, int startOffset)
        {
            string literal = "]";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchNot0(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral2(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchLiteral3(string text, int startOffset)
        {
            string literal = "\\";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchGroup1(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral3(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchOr1(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup1(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchAny(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchGroup2(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchOr1(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, StringMatchData matchData) MatchPatternAnyChar(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchGroup2(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "AnyChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 6 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 6;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 6;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchGroup2(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "AnyChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 6 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchPartByTextMatcherAnyChar(ref State state, FragmentMatchData matchData)
        {
            (bool success, StringMatchData partMatchData) = MatchPatternAnyChar(ref state, true, false);
            if (success)
            {
                matchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private bool MatchFragmentPartsOrderedModeCharacterRange(ref State state, FragmentMatchData matchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherAnyChar(ref state, matchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            (partSuccess, stringMatchData) = MatchPatternDash(ref state, true, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchPartByTextMatcherAnyChar(ref state, matchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

        Break:
            success = success || 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterRange(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            FragmentMatchData partMatcherData = null;
            int startIndex = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            partMatcherData = new FragmentMatchData { Name = "CharacterRange", StartIndex = state.CurrentIndex };
            success = (MatchFragmentPartsOrderedModeCharacterRange(ref state, partMatcherData));
            if (success)
            {
                partMatcherData.Length = state.CurrentIndex - partMatcherData.StartIndex;
                partMatcherData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                matchData.Parts.Add(partMatcherData);
            }

            return success;
        }

        private bool MatchFragmentPartsMultipleModeCharacterClassBody(ref State state, FragmentMatchData matchData)
        {
            bool overallSuccess = false;
            bool subSuccess = false;
            bool delimiterSuccess = false;
            StringMatchData range = default;
            int matchCount = 0;
            int distinctIndex = state.DistinctIndex;
            ;
            do
            {
                subSuccess = false;
                bool individualSuccess;
                individualSuccess = MatchFragmentHexRange(ref state, matchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    (delimiterSuccess, range) = (true, null);
                    goto Break;
                }

                individualSuccess = MatchPartByTextMatcherHexChar(ref state, matchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    (delimiterSuccess, range) = (true, null);
                    goto Break;
                }

                individualSuccess = MatchFragmentCharacterRange(ref state, matchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    (delimiterSuccess, range) = (true, null);
                    goto Break;
                }

                individualSuccess = MatchPartByTextMatcherAnyChar(ref state, matchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    (delimiterSuccess, range) = (true, null);
                    goto Break;
                }

            Break:
                overallSuccess |= subSuccess;
            }
            while (subSuccess && delimiterSuccess);
            if (delimiterSuccess && range != null)
            {
                state.CurrentIndex = range.StartIndex;
                state.DistinctIndex = distinctIndex;
            }

            bool thresholdSuccess = 1 <= matchCount;
            bool success = overallSuccess || thresholdSuccess;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterClassBody(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            FragmentMatchData partMatcherData = null;
            int startIndex = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            partMatcherData = new FragmentMatchData { Name = "CharacterClassBody", StartIndex = state.CurrentIndex };
            success = (MatchFragmentPartsMultipleModeCharacterClassBody(ref state, partMatcherData));
            if (success)
            {
                partMatcherData.Length = state.CurrentIndex - partMatcherData.StartIndex;
                partMatcherData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                matchData.Parts.Add(partMatcherData);
            }

            return success;
        }

        private bool MatchFragmentPartsOneModeNotCharacterClassBody(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentCharacterClassBody(ref state, matchData);
            if (success)
            {
                matchCount++;
            }

            success = false || matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentNotCharacterClassBody(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            FragmentMatchData partMatcherData = null;
            int startIndex = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            partMatcherData = new FragmentMatchData { Name = "NotCharacterClassBody", StartIndex = state.CurrentIndex };
            success = (MatchFragmentBoundsCaret(ref state, false, out StringMatchData startMatchData) && MatchFragmentPartsOneModeNotCharacterClassBody(ref state, partMatcherData));
            if (success)
            {
                partMatcherData.Length = state.CurrentIndex - partMatcherData.StartIndex;
                partMatcherData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                matchData.Parts.Add(partMatcherData);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral4(string text, int startOffset)
        {
            string literal = "[";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, StringMatchData matchData) MatchPatternOpenBracket(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchLiteral4(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "OpenBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 1 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 1;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 1;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchLiteral4(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "OpenBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 1 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchFragmentBoundsOpenBracket(ref State state, bool readOnly, out StringMatchData matchData)
        {
            bool success;
            (success, matchData) = MatchPatternOpenBracket(ref state, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentPartsOneModeCharacterClass(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentNotCharacterClassBody(ref state, matchData) || MatchFragmentCharacterClassBody(ref state, matchData);
            if (success)
            {
                matchCount++;
            }

            success = false || matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, StringMatchData matchData) MatchPatternCloseBracket(ref State state, bool required, bool readOnly = false)
        {
        Rerun:
            bool success = false;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                int startOffset = state.CurrentIndex;
                (success, length) = MatchLiteral2(state.Code, state.CurrentIndex);
                StringMatchData stringMatchData = default;
                if (success)
                {
                    stringMatchData = new StringMatchData { Name = "CloseBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 2 };
                    state.DistinctStringMatches.Add(stringMatchData);
                    success = stringMatchData != null;
                    state.MaxDistinctIndex++;
                    if (!readOnly)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
            else
            {
                StringMatchData stringMatchData = state.DistinctStringMatches[distinctIndex];
                if (stringMatchData != null)
                {
                    success = stringMatchData.Id != 2;
                    if (stringMatchData.IsNoise)
                    {
                        state.DistinctIndex++;
                        state.CurrentIndex += stringMatchData.Length;
                        goto Rerun;
                    }

                    success = stringMatchData.Id == 2;
                }
                else
                {
                    int length;
                    int startOffset = state.CurrentIndex;
                    (success, length) = MatchLiteral2(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        stringMatchData = new StringMatchData { Name = "CloseBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, IsNoise = false, Id = 2 };
                        state.DistinctStringMatches[distinctIndex] = stringMatchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex += stringMatchData.Length;
                }

                if (!required)
                {
                    success = true;
                }

                return (success, stringMatchData);
            }
        }

        private bool MatchFragmentBoundsCloseBracket(ref State state, bool readOnly, out StringMatchData matchData)
        {
            bool success;
            (success, matchData) = MatchPatternCloseBracket(ref state, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterClass(ref State state, FragmentMatchData matchData)
        {
            bool success = false;
            FragmentMatchData partMatcherData = null;
            int startIndex = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            partMatcherData = new FragmentMatchData { Name = "CharacterClass", StartIndex = state.CurrentIndex };
            success = (MatchFragmentBoundsOpenBracket(ref state, false, out StringMatchData startMatchData) && MatchFragmentPartsOneModeCharacterClass(ref state, partMatcherData) && MatchFragmentBoundsCloseBracket(ref state, false, out StringMatchData endMatchData));
            if (success)
            {
                partMatcherData.Length = state.CurrentIndex - partMatcherData.StartIndex;
                partMatcherData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                matchData.Parts.AddRange(partMatcherData.Parts);
            }

            return success;
        }
    }
}