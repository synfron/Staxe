/* Generated by Synfron.Staxe.Matcher v3.0.0.0*/
using Synfron.Staxe.Matcher.Data;
using Synfron.Staxe.Matcher.Input;
using System;
using System.Collections.Generic;
using System.Linq;

namespace Synfron.Staxe.Matcher
{
    public class CharacterClassMatchEngine : AbstractLanguageMatchEngine
    {
        public override MatcherResult Match(string code, string fragmentMatcher, bool matchFullText = true)
        {
            FragmentMatchData parentMatchData = new FragmentMatchData{StartIndex = 0};
            State state = new State()
            {Code = code};
            bool success = false;
            switch (fragmentMatcher)
            {
                case "CharacterClass":
                    success = MatchFragmentCharacterClass(ref state, parentMatchData);
                    break;
                case "NotCharacterClassBody":
                    success = MatchFragmentNotCharacterClassBody(ref state, parentMatchData);
                    break;
                case "CharacterClassBody":
                    success = MatchFragmentCharacterClassBody(ref state, parentMatchData);
                    break;
                case "CharacterRange":
                    success = MatchFragmentCharacterRange(ref state, parentMatchData);
                    break;
                case "HexRange":
                    success = MatchFragmentHexRange(ref state, parentMatchData);
                    break;
            }

            IMatchData resultMatchData = parentMatchData.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex < state.Code.Length)
            {
                success = false;
                failureIndex = state.CurrentIndex;
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        public override MatcherResult Match(string code, bool matchFullText = true)
        {
            FragmentMatchData parentMatchData = new FragmentMatchData{StartIndex = 0};
            State state = new State()
            {Code = code};
            bool success = MatchFragmentCharacterClass(ref state, parentMatchData);
            IMatchData resultMatchData = parentMatchData?.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex < state.Code.Length)
            {
                success = false;
                failureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        private (bool success, int offset) MatchLiteral0(string text, int startOffset)
        {
            string literal = "[";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternOpenBracket(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchLiteral0(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "OpenBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 1};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchFragmentBoundsOpenBracket(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            bool success = MatchPatternOpenBracket(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral1(string text, int startOffset)
        {
            string literal = "^";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternCaret(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchLiteral1(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "Caret", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 3};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchFragmentBoundsCaret(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            bool success = MatchPatternCaret(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchInsensitiveLiteral0(string text, int startOffset)
        {
            string literal = "#x";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (char.ToLowerInvariant(text[i + startOffset]) != char.ToLowerInvariant(literal[i]))
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchCharBounds0(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (97 <= charVal && 102 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds1(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (65 <= charVal && 70 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds2(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (48 <= charVal && 57 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchOr0(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchCharBounds0(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds1(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds2(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchCountBounds0(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            int subOffset;
            int matches = 0;
            for (; matches < 4 && subSuccess; matches++)
            {
                (subSuccess, subOffset) = MatchOr0(text, offset);
                offset += subOffset;
            }

            bool success = subSuccess || matches >= 1;
            return success ? (true, offset - startOffset) : (false, 0);
        }

        private (bool success, int offset) MatchGroup0(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchInsensitiveLiteral0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchCountBounds0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternHexChar(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchGroup0(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "HexChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 4};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchPartByTextMatcherHexChar(ref State state, FragmentMatchData parentMatchData)
        {
            StringMatchData partMatchData;
            bool success = MatchPatternHexChar(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral2(string text, int startOffset)
        {
            string literal = "-";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternDash(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchLiteral2(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "Dash", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 5};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchFragmentPartsOrderedModeHexRange(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherHexChar(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternDash(ref state, parentMatchData, out stringMatchData, true, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchPartByTextMatcherHexChar(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentHexRange(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "HexRange", StartIndex = -1};
            success = (MatchFragmentPartsOrderedModeHexRange(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral3(string text, int startOffset)
        {
            string literal = "]";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchNot0(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral3(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchLiteral4(string text, int startOffset)
        {
            string literal = "\\";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchGroup1(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral4(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchOr1(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup1(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchAny(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchGroup2(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchOr1(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternAnyChar(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchGroup2(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "AnyChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 6};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchPartByTextMatcherAnyChar(ref State state, FragmentMatchData parentMatchData)
        {
            StringMatchData partMatchData;
            bool success = MatchPatternAnyChar(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private bool MatchFragmentPartsOrderedModeCharacterRange(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherAnyChar(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternDash(ref state, parentMatchData, out stringMatchData, true, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchPartByTextMatcherAnyChar(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterRange(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "CharacterRange", StartIndex = -1};
            success = (MatchFragmentPartsOrderedModeCharacterRange(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private bool MatchFragmentPartsMultipleModeCharacterClassBody(ref State state, FragmentMatchData parentMatchData)
        {
            bool overallSuccess = false;
            bool subSuccess = false;
            bool delimiterSuccess = false;
            StringMatchData range = default;
            int matchCount = 0;
            int distinctIndex = state.DistinctIndex;
            ;
            do
            {
                subSuccess = false;
                bool individualSuccess;
                individualSuccess = MatchFragmentHexRange(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchPartByTextMatcherHexChar(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchFragmentCharacterRange(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchPartByTextMatcherAnyChar(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                Break:
                    overallSuccess |= subSuccess;
            }
            while (subSuccess && delimiterSuccess);
            if (delimiterSuccess && range != null)
            {
                state.CurrentIndex = range.StartIndex;
                state.DistinctIndex = distinctIndex;
            }

            bool success = 1 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterClassBody(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "CharacterClassBody", StartIndex = -1};
            success = (MatchFragmentPartsMultipleModeCharacterClassBody(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private bool MatchFragmentPartsOneModeNotCharacterClassBody(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentCharacterClassBody(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentNotCharacterClassBody(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "NotCharacterClassBody", StartIndex = -1};
            StringMatchData startMatchData;
            success = (MatchFragmentBoundsCaret(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeNotCharacterClassBody(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            return success;
        }

        private bool MatchFragmentPartsOneModeCharacterClass(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentNotCharacterClassBody(ref state, parentMatchData) || MatchFragmentCharacterClassBody(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchPatternCloseBracket(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int length;
            (success, length) = MatchLiteral3(state.Code, state.CurrentIndex);
            matchData = default;
            if (success)
            {
                matchData = new StringMatchData{Name = "CloseBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 2};
                if (!readOnly)
                {
                    state.CurrentIndex = startOffset + length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = startOffset;
                    }
                }
            }
            else if (!required)
            {
                success = true;
            }

            return success;
        }

        private bool MatchFragmentBoundsCloseBracket(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            bool success = MatchPatternCloseBracket(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCharacterClass(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "CharacterClass", StartIndex = -1};
            StringMatchData startMatchData;
            StringMatchData endMatchData = null;
            success = (MatchFragmentBoundsOpenBracket(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeCharacterClass(ref state, partMatchData) && MatchFragmentBoundsCloseBracket(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.AddRange(partMatchData.Parts);
            }

            return success;
        }
    }
}