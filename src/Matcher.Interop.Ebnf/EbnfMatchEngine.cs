/* Generated by Synfron.Staxe.Matcher v3.0.0.0*/
using Synfron.Staxe.Matcher.Data;
using Synfron.Staxe.Matcher.Input;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace Synfron.Staxe.Matcher
{
    public class EbnfMatchEngine : AbstractLanguageMatchEngine
    {
        public override MatcherResult Match(string code, string fragmentMatcher, bool matchFullText = true)
        {
            FragmentMatchData parentMatchData = new FragmentMatchData{StartIndex = 0};
            State state = new State()
            {Code = code, DistinctStringMatches = new List<StringMatchData>(2000), MatchCache = new Dictionary<ValueTuple<string, int>, FragmentMatchData>(), MatchLogBuilder = new StringBuilder()};
            state.PreMatchSuccess = PreMatchPatterns(ref state);
            bool success = false;
            switch (fragmentMatcher)
            {
                case "Rules":
                    success = MatchFragmentRules(ref state, parentMatchData);
                    break;
                case "RulePrefix":
                    success = MatchFragmentRulePrefix(ref state, parentMatchData);
                    break;
                case "NotRulePrefix":
                    success = MatchFragmentNotRulePrefix(ref state, parentMatchData);
                    break;
                case "RuleName":
                    success = MatchFragmentRuleName(ref state, parentMatchData);
                    break;
                case "Rule":
                    success = MatchFragmentRule(ref state, parentMatchData);
                    break;
                case "Expression":
                    success = MatchFragmentExpression(ref state, parentMatchData);
                    break;
                case "ExpressionSuffix":
                    success = MatchFragmentExpressionSuffix(ref state, parentMatchData);
                    break;
                case "RepetitionSuffix":
                    success = MatchFragmentRepetitionSuffix(ref state, parentMatchData);
                    break;
                case "ExceptSuffix":
                    success = MatchFragmentExceptSuffix(ref state, parentMatchData);
                    break;
                case "CommaSuffix":
                    success = MatchFragmentCommaSuffix(ref state, parentMatchData);
                    break;
                case "OrSuffix":
                    success = MatchFragmentOrSuffix(ref state, parentMatchData);
                    break;
                case "OptionalComma":
                    success = MatchFragmentOptionalComma(ref state, parentMatchData);
                    break;
                case "ExpressionValue":
                    success = MatchFragmentExpressionValue(ref state, parentMatchData);
                    break;
                case "ExpressionGroup":
                    success = MatchFragmentExpressionGroup(ref state, parentMatchData);
                    break;
                case "RepetitionGroup":
                    success = MatchFragmentRepetitionGroup(ref state, parentMatchData);
                    break;
                case "OptionalGroup":
                    success = MatchFragmentOptionalGroup(ref state, parentMatchData);
                    break;
                case "ZeroOrOneItem":
                    success = MatchFragmentZeroOrOneItem(ref state, parentMatchData);
                    break;
                case "OneOrMoreItem":
                    success = MatchFragmentOneOrMoreItem(ref state, parentMatchData);
                    break;
                case "ZeroOrMoreItem":
                    success = MatchFragmentZeroOrMoreItem(ref state, parentMatchData);
                    break;
                case "Item":
                    success = MatchFragmentItem(ref state, parentMatchData);
                    break;
            }

            IMatchData resultMatchData = parentMatchData.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex < (state.PreMatchSuccess ? state.DistinctStringMatches.LastOrDefault().GetEndIndex() : state.Code.Length))
            {
                success = false;
                failureIndex = state.CurrentIndex;
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        public override MatcherResult Match(string code, bool matchFullText = true)
        {
            FragmentMatchData parentMatchData = new FragmentMatchData{StartIndex = 0};
            State state = new State()
            {Code = code, DistinctStringMatches = new List<StringMatchData>(2000), MatchCache = new Dictionary<ValueTuple<string, int>, FragmentMatchData>(), MatchLogBuilder = new StringBuilder()};
            state.PreMatchSuccess = PreMatchPatterns(ref state);
            bool success = MatchFragmentRules(ref state, parentMatchData);
            IMatchData resultMatchData = parentMatchData?.Parts.FirstOrDefault();
            int? failureIndex = success ? null : state.FailureIndex;
            if (success && matchFullText && state.CurrentIndex < (state.PreMatchSuccess ? state.DistinctStringMatches.LastOrDefault().GetEndIndex() : state.Code.Length))
            {
                success = false;
                failureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return new MatcherResult(resultMatchData, success, state.CurrentIndex, failureIndex, state.MatchLogBuilder?.ToString());
        }

        private bool PreMatchPatterns(ref State state)
        {
            int codeLength = state.Code.Length;
            bool success = true;
            StringMatchData matchData = null;
            int currentIndex = 0;
            while (success && (currentIndex = state.CurrentIndex) < codeLength)
            {
                success = MatchPatternNumber(ref state, null, out matchData, true, false) || MatchPatternDoubleQuoteLiteral(ref state, null, out matchData, true, false) || MatchPatternSingleQuoteLiteral(ref state, null, out matchData, true, false) || MatchPatternOptionalGroup(ref state, null, out matchData, true, false) || MatchPatternSpecialGroup(ref state, null, out matchData, true, false) || MatchPatternComment(ref state, null, out matchData, true, false) || MatchPatternIs(ref state, null, out matchData, true, false) || MatchPatternRuleName(ref state, null, out matchData, true, false) || MatchPatternOr(ref state, null, out matchData, true, false) || MatchPatternAsterisk(ref state, null, out matchData, true, false) || MatchPatternPlus(ref state, null, out matchData, true, false) || MatchPatternQuestionMark(ref state, null, out matchData, true, false) || MatchPatternSemicolon(ref state, null, out matchData, true, false) || MatchPatternPeriod(ref state, null, out matchData, true, false) || MatchPatternOpenBrace(ref state, null, out matchData, true, false) || MatchPatternCloseBrace(ref state, null, out matchData, true, false) || MatchPatternOpenParens(ref state, null, out matchData, true, false) || MatchPatternCloseParens(ref state, null, out matchData, true, false) || MatchPatternWhitespace(ref state, null, out matchData, true, false) || MatchPatternComma(ref state, null, out matchData, true, false) || MatchPatternHexChar(ref state, null, out matchData, true, false) || MatchPatternDash(ref state, null, out matchData, true, false);
                if (matchData != null)
                {
                    state.MatchLogBuilder.AppendLine($"{currentIndex}. Prematched {matchData.Name}: {matchData.Text}");
                }
            }

            state.CurrentIndex = 0;
            state.DistinctIndex = 0;
            return success;
        }

        private (bool success, int offset) MatchOneOrMore2(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            bool success = false;
            int subOffset;
            while (subSuccess)
            {
                (subSuccess, subOffset) = MatchWhitespace(text, offset);
                offset += subOffset;
                success |= subSuccess;
            }

            return success ? (true, offset - startOffset) : (false, 0);
        }

        private bool MatchPatternWhitespace(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchOneOrMore2(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Whitespace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 21};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 21;
                }
                else
                {
                    (success, length) = MatchOneOrMore2(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Whitespace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 21};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private (bool success, int offset) MatchLiteral30(string text, int startOffset)
        {
            string literal = "<";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral31(string text, int startOffset)
        {
            string literal = "-";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral32(string text, int startOffset)
        {
            string literal = "_";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchOr4(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchWordChar(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchLiteral31(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchLiteral32(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchWildcard5(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchOr4(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchLiteral33(string text, int startOffset)
        {
            string literal = ">";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchGroup13(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral30(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLetter(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard5(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral33(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup14(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLetter(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard5(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchOr6(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup13(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchGroup14(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private bool MatchPatternRuleName(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchOr6(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "RuleName", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 10};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 10;
                }
                else
                {
                    (success, length) = MatchOr6(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "RuleName", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 10};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherRuleName(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ((\u003c\\l(\\w|-|_)*\u003e)|(\\l(\\w|-|_)*))");
            StringMatchData partMatchData;
            bool success = MatchPatternRuleName(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: ((\u003c\\l(\\w|-|_)*\u003e)|(\\l(\\w|-|_)*))");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeRuleName(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchPartByTextMatcherRuleName(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentRuleName(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: RuleName");
            if (!state.MatchCache.TryGetValue(new ValueTuple<string, int>("RuleName", state.CurrentIndex), out partMatchData))
            {
                int distinctIndex = state.DistinctIndex;
                partMatchData = new FragmentMatchData{Name = "RuleName", StartIndex = -1};
                success = (MatchFragmentPartsOneModeRuleName(ref state, partMatchData));
                if (success)
                {
                    partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                    partMatchData.EndDistinctIndex = state.DistinctIndex;
                    state.MatchCache[new ValueTuple<string, int>("RuleName", startIndex)] = partMatchData;
                }
                else
                {
                    state.MatchCache[new ValueTuple<string, int>("RuleName", startIndex)] = null;
                    state.CurrentIndex = startIndex;
                    state.DistinctIndex = distinctIndex;
                }
            }
            else if (success = partMatchData != null)
            {
                state.CurrentIndex = partMatchData.StartIndex + partMatchData.Length;
                state.DistinctIndex = partMatchData.EndDistinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: RuleName");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeRulePrefix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            success = MatchFragmentRuleName(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            if (success)
            {
                MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral26(string text, int startOffset)
        {
            string literal = "::=";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral27(string text, int startOffset)
        {
            string literal = ":=";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral28(string text, int startOffset)
        {
            string literal = ":";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral29(string text, int startOffset)
        {
            string literal = "=";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchOr3(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral26(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchLiteral27(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchLiteral28(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchLiteral29(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private bool MatchPatternIs(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchOr3(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Is", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 9};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 9;
                }
                else
                {
                    (success, length) = MatchOr3(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Is", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 9};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsIs(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternIs(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"(::=|:=|:|=)"}");
            return success;
        }

        private bool MatchFragmentRulePrefix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: RulePrefix");
            if (!state.MatchCache.TryGetValue(new ValueTuple<string, int>("RulePrefix", state.CurrentIndex), out partMatchData))
            {
                int distinctIndex = state.DistinctIndex;
                partMatchData = new FragmentMatchData{Name = "RulePrefix", StartIndex = -1};
                StringMatchData endMatchData = null;
                success = (MatchFragmentPartsOneModeRulePrefix(ref state, partMatchData) && MatchFragmentBoundsIs(ref state, partMatchData, false, out endMatchData));
                if (success)
                {
                    partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                    partMatchData.EndDistinctIndex = state.DistinctIndex;
                    state.MatchCache[new ValueTuple<string, int>("RulePrefix", startIndex)] = partMatchData;
                }
                else
                {
                    state.MatchCache[new ValueTuple<string, int>("RulePrefix", startIndex)] = null;
                    state.CurrentIndex = startIndex;
                    state.DistinctIndex = distinctIndex;
                }
            }
            else if (success = partMatchData != null)
            {
                state.CurrentIndex = partMatchData.StartIndex + partMatchData.Length;
                state.DistinctIndex = partMatchData.EndDistinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.AddRange(partMatchData.Parts);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: RulePrefix");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral0(string text, int startOffset)
        {
            string literal = "\"";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchNot0(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral0(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchGroup0(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchWildcard0(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchGroup0(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup1(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternDoubleQuoteLiteral(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchGroup1(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "DoubleQuoteLiteral", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 2};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 2;
                }
                else
                {
                    (success, length) = MatchGroup1(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "DoubleQuoteLiteral", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 2};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherDoubleQuoteLiteral(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: (\"(\"!.)*\")");
            StringMatchData partMatchData;
            bool success = MatchPatternDoubleQuoteLiteral(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: (\"(\"!.)*\")");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral3(string text, int startOffset)
        {
            string literal = "'";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchNot1(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral3(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchGroup2(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot1(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchWildcard1(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchGroup2(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup3(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral3(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard1(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral3(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternSingleQuoteLiteral(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchGroup3(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "SingleQuoteLiteral", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 3};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 3;
                }
                else
                {
                    (success, length) = MatchGroup3(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "SingleQuoteLiteral", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 3};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherSingleQuoteLiteral(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: (\u0027(\u0027!.)*\u0027)");
            StringMatchData partMatchData;
            bool success = MatchPatternSingleQuoteLiteral(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: (\u0027(\u0027!.)*\u0027)");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral44(string text, int startOffset)
        {
            string literal = "(";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternOpenParens(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral44(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "OpenParens", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 19};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 19;
                }
                else
                {
                    (success, length) = MatchLiteral44(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "OpenParens", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 19};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsOpenParens(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternOpenParens(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\("}");
            return success;
        }

        private bool MatchFragmentPartsOneModeExpressionGroup(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            success = MatchFragmentExpression(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            if (success)
            {
                MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral45(string text, int startOffset)
        {
            string literal = ")";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternCloseParens(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral45(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "CloseParens", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 20};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 20;
                }
                else
                {
                    (success, length) = MatchLiteral45(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "CloseParens", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 20};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsCloseParens(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternCloseParens(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\)"}");
            return success;
        }

        private bool MatchFragmentExpressionGroup(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ExpressionGroup");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ExpressionGroup", StartIndex = -1};
            StringMatchData startMatchData;
            StringMatchData endMatchData = null;
            success = (MatchFragmentBoundsOpenParens(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeExpressionGroup(ref state, partMatchData) && MatchFragmentBoundsCloseParens(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.AddRange(partMatchData.Parts);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ExpressionGroup");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral42(string text, int startOffset)
        {
            string literal = "{";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternOpenBrace(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral42(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "OpenBrace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 17};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 17;
                }
                else
                {
                    (success, length) = MatchLiteral42(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "OpenBrace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 17};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsOpenBrace(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternOpenBrace(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\{"}");
            return success;
        }

        private (bool success, int offset) MatchLiteral43(string text, int startOffset)
        {
            string literal = "}";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternCloseBrace(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral43(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "CloseBrace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 18};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 18;
                }
                else
                {
                    (success, length) = MatchLiteral43(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "CloseBrace", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 18};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsCloseBrace(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternCloseBrace(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\}"}");
            return success;
        }

        private bool MatchFragmentRepetitionGroup(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: RepetitionGroup");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "RepetitionGroup", StartIndex = -1};
            StringMatchData startMatchData;
            StringMatchData endMatchData = null;
            success = (MatchFragmentBoundsOpenBrace(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeExpressionGroup(ref state, partMatchData) && MatchFragmentBoundsCloseBrace(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: RepetitionGroup");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral6(string text, int startOffset)
        {
            string literal = "[";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternOpenBracket(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral6(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "OpenBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 5};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 5;
                }
                else
                {
                    (success, length) = MatchLiteral6(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "OpenBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 5};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsOpenBracket(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternOpenBracket(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\["}");
            return success;
        }

        private (bool success, int offset) MatchLiteral7(string text, int startOffset)
        {
            string literal = "]";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternCloseBracket(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral7(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "CloseBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 6};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 6;
                }
                else
                {
                    (success, length) = MatchLiteral7(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "CloseBracket", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 6};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsCloseBracket(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternCloseBracket(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\]"}");
            return success;
        }

        private bool MatchFragmentOptionalGroup(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: OptionalGroup");
            if (!state.MatchCache.TryGetValue(new ValueTuple<string, int>("OptionalGroup", state.CurrentIndex), out partMatchData))
            {
                int distinctIndex = state.DistinctIndex;
                partMatchData = new FragmentMatchData{Name = "OptionalGroup", StartIndex = -1};
                StringMatchData startMatchData;
                StringMatchData endMatchData = null;
                success = (MatchFragmentBoundsOpenBracket(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeExpressionGroup(ref state, partMatchData) && MatchFragmentBoundsCloseBracket(ref state, partMatchData, false, out endMatchData));
                if (success)
                {
                    partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                    partMatchData.EndDistinctIndex = state.DistinctIndex;
                    state.MatchCache[new ValueTuple<string, int>("OptionalGroup", startIndex)] = partMatchData;
                }
                else
                {
                    state.MatchCache[new ValueTuple<string, int>("OptionalGroup", startIndex)] = null;
                    state.CurrentIndex = startIndex;
                    state.DistinctIndex = distinctIndex;
                }
            }
            else if (success = partMatchData != null)
            {
                state.CurrentIndex = partMatchData.StartIndex + partMatchData.Length;
                state.DistinctIndex = partMatchData.EndDistinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: OptionalGroup");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchNot2(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral6(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchNot3(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral7(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchGroup4(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot2(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchNot3(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchLiteral11(string text, int startOffset)
        {
            string literal = "\\";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchGroup5(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral11(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral6(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup6(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral11(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral7(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchOr0(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup5(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchGroup6(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchOr1(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup4(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchOr0(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchOneOrMore1(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            bool success = false;
            int subOffset;
            while (subSuccess)
            {
                (subSuccess, subOffset) = MatchOr1(text, offset);
                offset += subOffset;
                success |= subSuccess;
            }

            return success ? (true, offset - startOffset) : (false, 0);
        }

        private (bool success, int offset) MatchGroup7(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral6(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchOneOrMore1(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral7(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternSpecialGroup(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchGroup7(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "SpecialGroup", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 7};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 7;
                }
                else
                {
                    (success, length) = MatchGroup7(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "SpecialGroup", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 7};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherSpecialGroup(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: (\\[((\\[!\\]!.)|((\\\\\\[)|(\\\\\\])))+\\])");
            StringMatchData partMatchData;
            bool success = MatchPatternSpecialGroup(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: (\\[((\\[!\\]!.)|((\\\\\\[)|(\\\\\\])))+\\])");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchInsensitiveLiteral0(string text, int startOffset)
        {
            string literal = "#x";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (char.ToLowerInvariant(text[i + startOffset]) != char.ToLowerInvariant(literal[i]))
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchCharBounds0(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (97 <= charVal && 102 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds1(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (65 <= charVal && 70 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchCharBounds2(string text, int startOffset)
        {
            int charVal = text[startOffset];
            return (48 <= charVal && 57 >= charVal) ? (true, 1) : (false, 0);
        }

        private (bool success, int offset) MatchOr7(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchCharBounds0(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds1(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchCharBounds2(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchCountBounds0(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            int subOffset;
            int matches = 0;
            for (; matches < 4 && subSuccess; matches++)
            {
                (subSuccess, subOffset) = MatchOr7(text, offset);
                offset += subOffset;
            }

            bool success = subSuccess || matches >= 1;
            return success ? (true, offset - startOffset) : (false, 0);
        }

        private (bool success, int offset) MatchGroup15(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchInsensitiveLiteral0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchCountBounds0(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternHexChar(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchGroup15(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "HexChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 23};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 23;
                }
                else
                {
                    (success, length) = MatchGroup15(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "HexChar", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 23};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherHexChar(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ~#x([a-f]|[A-F]|[0-9]){1, 4}");
            StringMatchData partMatchData;
            bool success = MatchPatternHexChar(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: ~#x([a-f]|[A-F]|[0-9]){1, 4}");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchOneOrMore0(string text, int startOffset)
        {
            int offset = startOffset;
            bool subSuccess = true;
            bool success = false;
            int subOffset;
            while (subSuccess)
            {
                (subSuccess, subOffset) = MatchDigit(text, offset);
                offset += subOffset;
                success |= subSuccess;
            }

            return success ? (true, offset - startOffset) : (false, 0);
        }

        private bool MatchPatternNumber(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchOneOrMore0(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Number", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 1};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 1;
                }
                else
                {
                    (success, length) = MatchOneOrMore0(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Number", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 1};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherNumber(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: \\d+");
            StringMatchData partMatchData;
            bool success = MatchPatternNumber(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: \\d+");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchPartByTextMatcherDoubleQuoteLiteral(ref state, parentMatchData) || MatchPartByTextMatcherSingleQuoteLiteral(ref state, parentMatchData) || MatchFragmentExpressionGroup(ref state, parentMatchData) || MatchFragmentRepetitionGroup(ref state, parentMatchData) || MatchFragmentOptionalGroup(ref state, parentMatchData) || MatchPartByTextMatcherSpecialGroup(ref state, parentMatchData) || MatchFragmentRuleName(ref state, parentMatchData) || MatchPartByTextMatcherHexChar(ref state, parentMatchData) || MatchPartByTextMatcherNumber(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: Item");
            if (!state.MatchCache.TryGetValue(new ValueTuple<string, int>("Item", state.CurrentIndex), out partMatchData))
            {
                int distinctIndex = state.DistinctIndex;
                partMatchData = new FragmentMatchData{Name = "Item", StartIndex = -1};
                success = (MatchFragmentPartsOneModeItem(ref state, partMatchData));
                if (success)
                {
                    partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                    partMatchData.EndDistinctIndex = state.DistinctIndex;
                    state.MatchCache[new ValueTuple<string, int>("Item", startIndex)] = partMatchData;
                }
                else
                {
                    state.MatchCache[new ValueTuple<string, int>("Item", startIndex)] = null;
                    state.CurrentIndex = startIndex;
                    state.DistinctIndex = distinctIndex;
                }
            }
            else if (success = partMatchData != null)
            {
                state.CurrentIndex = partMatchData.StartIndex + partMatchData.Length;
                state.DistinctIndex = partMatchData.EndDistinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: Item");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeZeroOrOneItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentItem(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private (bool success, int offset) MatchLiteral39(string text, int startOffset)
        {
            string literal = "?";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternQuestionMark(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral39(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "QuestionMark", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 14};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 14;
                }
                else
                {
                    (success, length) = MatchLiteral39(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "QuestionMark", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 14};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsQuestionMark(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternQuestionMark(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\?"}");
            return success;
        }

        private bool MatchFragmentZeroOrOneItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ZeroOrOneItem");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ZeroOrOneItem", StartIndex = -1};
            StringMatchData endMatchData = null;
            success = (MatchFragmentPartsOneModeZeroOrOneItem(ref state, partMatchData) && MatchFragmentBoundsQuestionMark(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ZeroOrOneItem");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral38(string text, int startOffset)
        {
            string literal = "+";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternPlus(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral38(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Plus", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 13};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 13;
                }
                else
                {
                    (success, length) = MatchLiteral38(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Plus", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 13};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsPlus(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternPlus(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\+"}");
            return success;
        }

        private bool MatchFragmentOneOrMoreItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: OneOrMoreItem");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "OneOrMoreItem", StartIndex = -1};
            StringMatchData endMatchData = null;
            success = (MatchFragmentPartsOneModeZeroOrOneItem(ref state, partMatchData) && MatchFragmentBoundsPlus(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: OneOrMoreItem");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral37(string text, int startOffset)
        {
            string literal = "*";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternAsterisk(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral37(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Asterisk", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 12};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 12;
                }
                else
                {
                    (success, length) = MatchLiteral37(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Asterisk", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 12};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchFragmentBoundsAsterisk(ref State state, FragmentMatchData parentMatchData, bool readOnly, out StringMatchData matchData)
        {
            int startIndex = state.CurrentIndex;
            bool success = MatchPatternAsterisk(ref state, parentMatchData, out matchData, true, readOnly);
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {(success && matchData != null ? matchData.StartIndex + matchData.Length : startIndex)}. {(success ? "Passed" : "Failed")} Bounds: {"\\*"}");
            return success;
        }

        private bool MatchFragmentZeroOrMoreItem(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ZeroOrMoreItem");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ZeroOrMoreItem", StartIndex = -1};
            StringMatchData endMatchData = null;
            success = (MatchFragmentPartsOneModeZeroOrOneItem(ref state, partMatchData) && MatchFragmentBoundsAsterisk(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ZeroOrMoreItem");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeExpressionValue(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            success = MatchFragmentZeroOrOneItem(ref state, parentMatchData) || MatchFragmentOneOrMoreItem(ref state, parentMatchData) || MatchFragmentZeroOrMoreItem(ref state, parentMatchData) || MatchFragmentItem(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            if (success)
            {
                MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentExpressionValue(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ExpressionValue");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ExpressionValue", StartIndex = -1};
            success = (MatchFragmentPartsOneModeExpressionValue(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.AddRange(partMatchData.Parts);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ExpressionValue");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral36(string text, int startOffset)
        {
            string literal = "|";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternOr(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral36(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Or", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 11};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 11;
                }
                else
                {
                    (success, length) = MatchLiteral36(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Or", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 11};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherOr(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: \\|");
            StringMatchData partMatchData;
            bool success = MatchPatternOr(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: \\|");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOrderedModeOrSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            success = MatchPartByTextMatcherOr(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpressionValue(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                if (success)
                {
                    MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
                }

            success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentOrSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: OrSuffix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "OrSuffix", StartIndex = -1, ExpressionOrder = 4};
            success = (MatchFragmentPartsOrderedModeOrSuffix(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: OrSuffix");
            state.Id--;
            return success;
        }

        private bool MatchPartByTextMatcherAsterisk(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: \\*");
            StringMatchData partMatchData;
            bool success = MatchPatternAsterisk(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: \\*");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOrderedModeRepetitionSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherAsterisk(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpressionValue(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentRepetitionSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: RepetitionSuffix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "RepetitionSuffix", StartIndex = -1, ExpressionOrder = 1};
            success = (MatchFragmentPartsOrderedModeRepetitionSuffix(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: RepetitionSuffix");
            state.Id--;
            return success;
        }

        private bool MatchPatternDash(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral31(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Dash", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 24};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 24;
                }
                else
                {
                    (success, length) = MatchLiteral31(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Dash", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 24};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherDash(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: -");
            StringMatchData partMatchData;
            bool success = MatchPatternDash(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: -");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOrderedModeExceptSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchPartByTextMatcherDash(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpressionValue(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentExceptSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ExceptSuffix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ExceptSuffix", StartIndex = -1, ExpressionOrder = 2};
            success = (MatchFragmentPartsOrderedModeExceptSuffix(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ExceptSuffix");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral46(string text, int startOffset)
        {
            string literal = ",";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternComma(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral46(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Comma", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 22};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 22;
                }
                else
                {
                    (success, length) = MatchLiteral46(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Comma", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 22};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherComma(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ,");
            StringMatchData partMatchData;
            bool success = MatchPatternComma(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: ,");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeOptionalComma(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchPartByTextMatcherComma(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = true;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentOptionalComma(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: OptionalComma");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "OptionalComma", StartIndex = -1};
            success = (MatchFragmentPartsOneModeOptionalComma(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: OptionalComma");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeNotRulePrefix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchFragmentRulePrefix(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentNotRulePrefix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: NotRulePrefix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "NotRulePrefix", StartIndex = -1};
            success = (MatchFragmentPartsOneModeNotRulePrefix(ref state, partMatchData));
            if (success)
            {
            }

            state.CurrentIndex = startIndex;
            state.DistinctIndex = distinctIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(!success ? "Passed" : "Failed")}: NotRulePrefix");
            state.Id--;
            return !success;
        }

        private bool MatchFragmentPartsOrderedModeCommaSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchFragmentOptionalComma(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentNotRulePrefix(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpressionValue(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 3 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentCommaSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: CommaSuffix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "CommaSuffix", StartIndex = -1, ExpressionOrder = 3};
            success = (MatchFragmentPartsOrderedModeCommaSuffix(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: CommaSuffix");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsMultipleModeExpressionSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool overallSuccess = false;
            bool subSuccess = false;
            bool delimiterSuccess = false;
            StringMatchData range = default;
            int matchCount = 0;
            int distinctIndex = state.DistinctIndex;
            ;
            do
            {
                subSuccess = false;
                bool individualSuccess;
                individualSuccess = MatchFragmentOrSuffix(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchFragmentRepetitionSuffix(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchFragmentExceptSuffix(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                individualSuccess = MatchFragmentCommaSuffix(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = true;
                    goto Break;
                }

                Break:
                    overallSuccess |= subSuccess;
            }
            while (subSuccess && delimiterSuccess);
            if (delimiterSuccess && range != null)
            {
                state.CurrentIndex = range.StartIndex;
                state.DistinctIndex = distinctIndex;
            }

            bool success = 0 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentExpressionSuffix(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ExpressionSuffix");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "ExpressionSuffix", StartIndex = -1};
            success = (MatchFragmentPartsMultipleModeExpressionSuffix(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.AddRange(partMatchData.Parts);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: ExpressionSuffix");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOrderedModeExpression(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            success = MatchFragmentExpressionValue(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpressionSuffix(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                if (success)
                {
                    MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
                }

            success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentExpression(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: Expression");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "Expression", StartIndex = -1};
            success = (MatchFragmentPartsOrderedModeExpression(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
                ConvertToExpressionTree(partMatchData, ExpressionMode.LikeNameTree);
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: Expression");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral40(string text, int startOffset)
        {
            string literal = ";";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternSemicolon(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral40(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Semicolon", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 15};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 15;
                }
                else
                {
                    (success, length) = MatchLiteral40(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Semicolon", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 15};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherSemicolon(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: ;");
            StringMatchData partMatchData;
            bool success = MatchPatternSemicolon(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: ;");
            state.Id--;
            return success;
        }

        private (bool success, int offset) MatchLiteral41(string text, int startOffset)
        {
            string literal = ".";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private bool MatchPatternPeriod(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchLiteral41(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Period", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 16};
                    state.DistinctStringMatches.Add(matchData);
                    state.MaxDistinctIndex++;
                    state.DistinctIndex++;
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 16;
                }
                else
                {
                    (success, length) = MatchLiteral41(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Period", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 16};
                        state.DistinctStringMatches[distinctIndex] = matchData;
                    }
                }

                if (success && !readOnly)
                {
                    state.DistinctIndex++;
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }

        private bool MatchPartByTextMatcherPeriod(ref State state, FragmentMatchData parentMatchData)
        {
            state.Id++;
            int startIndex = state.CurrentIndex;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: \\.");
            StringMatchData partMatchData;
            bool success = MatchPatternPeriod(ref state, parentMatchData, out partMatchData, true, false);
            if (success)
            {
                parentMatchData.Parts.Add(partMatchData);
                state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id + 1)} {partMatchData?.StartIndex ?? startIndex}. Matched: {partMatchData.Text}");
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {(success && partMatchData != null ? partMatchData.StartIndex + partMatchData.Length : startIndex)}. {(success ? "Passed" : "Failed")}: \\.");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOneModeEndMark(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int matchCount = 0;
            success = MatchPartByTextMatcherSemicolon(ref state, parentMatchData) || MatchPartByTextMatcherPeriod(ref state, parentMatchData);
            if (success)
            {
                matchCount++;
            }

            success = matchCount > 0;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentEndMark(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: EndMark");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "EndMark", StartIndex = -1};
            success = (MatchFragmentPartsOneModeEndMark(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: EndMark");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsOrderedModeRule(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = true;
            bool partSuccess;
            int matchCount = 0;
            StringMatchData stringMatchData = null;
            int distinctIndex = state.DistinctIndex;
            ;
            success = MatchFragmentRulePrefix(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentExpression(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            distinctIndex = state.DistinctIndex;
            partSuccess = MatchPatternWhitespace(ref state, parentMatchData, out stringMatchData, false, false);
            success = partSuccess;
            if (!success)
            {
                goto Break;
            }

            success = MatchFragmentEndMark(ref state, parentMatchData);
            if (!success)
            {
                if (stringMatchData != null)
                {
                    state.CurrentIndex = stringMatchData.StartIndex;
                    state.DistinctIndex = distinctIndex;
                }

                goto Break;
            }
            else
            {
                matchCount++;
            }

            Break:
                success = 2 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentRule(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: Rule");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "Rule", StartIndex = -1};
            success = (MatchFragmentPartsOrderedModeRule(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: Rule");
            state.Id--;
            return success;
        }

        private bool MatchFragmentPartsMultipleModeRules(ref State state, FragmentMatchData parentMatchData)
        {
            bool overallSuccess = false;
            bool subSuccess = false;
            bool delimiterSuccess = false;
            StringMatchData range = default;
            int matchCount = 0;
            int distinctIndex = state.DistinctIndex;
            MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            do
            {
                subSuccess = false;
                bool individualSuccess;
                individualSuccess = MatchFragmentRule(ref state, parentMatchData);
                subSuccess |= individualSuccess;
                if (individualSuccess)
                {
                    matchCount++;
                    distinctIndex = state.DistinctIndex;
                    delimiterSuccess = MatchPatternWhitespace(ref state, parentMatchData, out range, false, false);
                    goto Break;
                }

                Break:
                    overallSuccess |= subSuccess;
            }
            while (subSuccess && delimiterSuccess);
            if (delimiterSuccess && range != null)
            {
                state.CurrentIndex = range.StartIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (overallSuccess)
            {
                MatchPatternWhitespace(ref state, parentMatchData, out _, false, false);
            }

            bool success = 1 <= matchCount;
            if (!success)
            {
                state.FailureIndex = Math.Max(state.FailureIndex ?? 0, state.CurrentIndex);
            }

            return success;
        }

        private bool MatchFragmentRules(ref State state, FragmentMatchData parentMatchData)
        {
            bool success = false;
            int startIndex = state.CurrentIndex;
            FragmentMatchData partMatchData = null;
            state.Id++;
            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {startIndex}. Try: Rules");
            int distinctIndex = state.DistinctIndex;
            partMatchData = new FragmentMatchData{Name = "Rules", StartIndex = -1};
            success = (MatchFragmentPartsMultipleModeRules(ref state, partMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
            }
            else
            {
                state.CurrentIndex = startIndex;
                state.DistinctIndex = distinctIndex;
            }

            if (success)
            {
                if (parentMatchData.StartIndex < 0)
                {
                    parentMatchData.StartIndex = partMatchData.StartIndex;
                }

                parentMatchData.Parts.Add(partMatchData);
            }

            state.MatchLogBuilder.AppendLine($"{new String('\t', state.Id)} {state.CurrentIndex}. {(success ? "Passed" : "Failed")}: Rules");
            state.Id--;
            return success;
        }

        private bool MatchPatternOptionalGroup(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            int maxDistinctIndex = state.MaxDistinctIndex;
            StringMatchData lastDistinctMatchData = state.DistinctStringMatches.LastOrDefault();
            int cacheIndex = lastDistinctMatchData != null ? lastDistinctMatchData.StartIndex + lastDistinctMatchData.Length : 0;
            FragmentMatchData partMatchData;
            partMatchData = new FragmentMatchData{Name = "OptionalGroup", StartIndex = -1};
            StringMatchData startMatchData;
            StringMatchData endMatchData = null;
            success = (MatchFragmentBoundsOpenBracket(ref state, partMatchData, false, out startMatchData) && MatchFragmentPartsOneModeExpressionGroup(ref state, partMatchData) && MatchFragmentBoundsCloseBracket(ref state, partMatchData, false, out endMatchData));
            if (success)
            {
                partMatchData.Length = state.CurrentIndex - partMatchData.StartIndex;
                partMatchData.EndDistinctIndex = state.DistinctIndex;
                state.MatchCache[new ValueTuple<string, int>("OptionalGroup", cacheIndex)] = partMatchData;
                partMatchData.EndDistinctIndex = distinctIndex;
            }

            state.DistinctStringMatches.RemoveRange(distinctIndex, state.DistinctIndex - distinctIndex);
            state.DistinctIndex = distinctIndex;
            state.MaxDistinctIndex = maxDistinctIndex;
            if (!success)
            {
                state.CurrentIndex = startOffset;
            }

            matchData = null;
            return success;
        }

        private (bool success, int offset) MatchNot4(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral45(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchGroup8(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral37(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchNot4(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchWildcard2(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchGroup8(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup9(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral44(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral37(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard2(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral37(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral45(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchLiteral22(string text, int startOffset)
        {
            string literal = "/";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchLiteral24(string text, int startOffset)
        {
            string literal = "*/";
            int length = literal.Length;
            if (startOffset + length > text.Length)
            {
                return (false, 0);
            }

            for (int i = 0; i < length; i++)
            {
                if (text[i + startOffset] != literal[i])
                {
                    return (false, 0);
                }
            }

            return (true, length);
        }

        private (bool success, int offset) MatchNot5(string text, int startOffset)
        {
            return text.Length > startOffset && !MatchLiteral24(text, startOffset).success ? (true, 0) : (false, 0);
        }

        private (bool success, int offset) MatchGroup10(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchNot5(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchAny(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchWildcard3(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchGroup10(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup11(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchLiteral22(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral37(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard3(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchLiteral24(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchOr2(string text, int startOffset)
        {
            bool success;
            int subOffset;
            (success, subOffset) = MatchGroup9(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            (success, subOffset) = MatchGroup11(text, startOffset);
            if (success)
            {
                return (true, subOffset);
            }

            return (false, 0);
        }

        private (bool success, int offset) MatchWildcard4(string text, int startOffset)
        {
            int offset = startOffset;
            bool success = true;
            int subOffset;
            while (success)
            {
                (success, subOffset) = MatchWhitespace(text, offset);
                offset += subOffset;
            }

            return (true, offset - startOffset);
        }

        private (bool success, int offset) MatchGroup12(string text, int startOffset)
        {
            int offset = startOffset;
            bool success;
            int subOffset;
            (success, subOffset) = MatchOr2(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            (success, subOffset) = MatchWildcard4(text, offset);
            if (!success)
            {
                return (false, 0);
            }

            offset += subOffset;
            return (true, offset - startOffset);
        }

        private bool MatchPatternComment(ref State state, FragmentMatchData fragmentMatchData, out StringMatchData matchData, bool required, bool readOnly = false)
        {
            bool success = false;
            int startOffset = state.CurrentIndex;
            int distinctIndex = state.DistinctIndex;
            if (distinctIndex >= state.MaxDistinctIndex)
            {
                int length;
                (success, length) = MatchGroup12(state.Code, state.CurrentIndex);
                matchData = default;
                if (success)
                {
                    matchData = new StringMatchData{Name = "Comment", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 8};
                    if (!readOnly)
                    {
                        state.CurrentIndex = startOffset + length;
                        if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                        {
                            fragmentMatchData.StartIndex = startOffset;
                        }
                    }
                }
                else if (!required)
                {
                    success = true;
                }

                return success;
            }
            else
            {
                int length;
                matchData = state.DistinctStringMatches[distinctIndex];
                if (matchData != null)
                {
                    success = matchData.Id == 8;
                }
                else
                {
                    (success, length) = MatchGroup12(state.Code, state.CurrentIndex);
                    if (success)
                    {
                        matchData = new StringMatchData{Name = "Comment", Text = state.Code.Substring(startOffset, length), StartIndex = startOffset, Length = length, Id = 8};
                    }
                }

                if (success && !readOnly)
                {
                    state.CurrentIndex = matchData.StartIndex + matchData.Length;
                    if ((fragmentMatchData?.StartIndex ?? 0) < 0)
                    {
                        fragmentMatchData.StartIndex = matchData.StartIndex;
                    }
                }

                if (!required)
                {
                    success = true;
                }

                return success;
            }
        }
    }
}